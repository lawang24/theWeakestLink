{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/catas/Desktop/Basic Chess Game/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/catas/Desktop/Basic Chess Game/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/catas/Desktop/Basic Chess Game/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\n/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nvar EMPTY = -1;\nvar FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nexports.SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nvar BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n// NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n// ----------------------------------------------------------------------------\n// From https://github.com/jhlywa/chess.js/issues/230\n//\n// A lot of people are confused when they first see the internal representation\n// of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n// stores the board as an 8x16 array. This is purely for efficiency but has a\n// couple of interesting benefits:\n//\n// 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n//    square with 0x88, if the result is non-zero then the square is off the\n//    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n//    there are 8 possible directions in which the knight can move. These\n//    directions are relative to the 8x16 board and are stored in the\n//    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n//    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n//    (because of two-complement representation of -18). The non-zero result\n//    means the square is off the board and the move is illegal. Take the\n//    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n//    means the square is on the board.\n//\n// 2. The relative distance (or difference) between two squares on a 8x16 board\n//    is unique and can be used to inexpensively determine if a piece on a\n//    square can attack any other arbitrary square. For example, let's see if a\n//    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n//    -80. We add 119 to make the ATTACKS array index non-negative (because the\n//    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n//    bitmask of pieces that can attack from that distance and direction.\n//    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n//    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n//    example, we would check to see if 24 & 0x1 is non-zero, which it is\n//    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n//    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n//    there are no blocking pieces between E7 and E2. That's where the RAYS\n//    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n//    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n// prettier-ignore\nvar Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nvar PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nvar PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nvar ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nvar RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nvar PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nvar SYMBOLS = 'pnbrqkPNBRQK';\nvar PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nvar RANK_1 = 7;\nvar RANK_2 = 6;\n// const RANK_3 = 5\n// const RANK_4 = 4\n// const RANK_5 = 3\n// const RANK_6 = 2\nvar RANK_7 = 1;\nvar RANK_8 = 0;\nvar ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nvar SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nvar TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n/**\n * Extracts the zero-based rank of an 0x88 square.\n */\nfunction rank(square) {\n  return square >> 4;\n}\n/**\n * Extracts the zero-based file of an 0x88 square.\n */\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n/**\n * Converts a 0x88 square to algebraic notation.\n */\nfunction algebraic(square) {\n  var f = file(square);\n  var r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n/* TODO: this needs a bit of work - it validates structure but completely\n * ignores content (e.g. doesn't verify that each side has a king) ... we should\n * rewrite this, and ditch the silly error_number field while we're at it */\nfunction validateFen(fen) {\n  var errors = [];\n  errors[0] = 'No errors.';\n  errors[1] = 'FEN string must contain six space-delimited fields.';\n  errors[2] = '6th field (move number) must be a positive integer.';\n  errors[3] = '5th field (half move counter) must be a non-negative integer.';\n  errors[4] = '4th field (en-passant square) is invalid.';\n  errors[5] = '3rd field (castling availability) is invalid.';\n  errors[6] = '2nd field (side to move) is invalid.';\n  errors[7] = \"1st field (piece positions) does not contain 8 '/'-delimited rows.\";\n  errors[8] = '1st field (piece positions) is invalid [consecutive numbers].';\n  errors[9] = '1st field (piece positions) is invalid [invalid piece].';\n  errors[10] = '1st field (piece positions) is invalid [row too large].';\n  errors[11] = 'Illegal en-passant square';\n  /* 1st criterion: 6 space-seperated fields? */\n  var tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      valid: false,\n      errorNumber: 1,\n      error: errors[1]\n    };\n  }\n  /* 2nd criterion: move number field is a integer value > 0? */\n  var moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      valid: false,\n      errorNumber: 2,\n      error: errors[2]\n    };\n  }\n  /* 3rd criterion: half move counter is an integer >= 0? */\n  var halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      valid: false,\n      errorNumber: 3,\n      error: errors[3]\n    };\n  }\n  /* 4th criterion: 4th field is a valid e.p.-string? */\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      valid: false,\n      errorNumber: 4,\n      error: errors[4]\n    };\n  }\n  /* 5th criterion: 3th field is a valid castle-string? */\n  if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n    return {\n      valid: false,\n      errorNumber: 5,\n      error: errors[5]\n    };\n  }\n  /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      valid: false,\n      errorNumber: 6,\n      error: errors[6]\n    };\n  }\n  /* 7th criterion: 1st field contains 8 rows? */\n  var rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      valid: false,\n      errorNumber: 7,\n      error: errors[7]\n    };\n  }\n  /* 8th criterion: every row is valid? */\n  for (var i = 0; i < rows.length; i++) {\n    /* check for right sum of fields AND not two numbers in succession */\n    var sumFields = 0;\n    var previousWasNumber = false;\n    for (var k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            valid: false,\n            errorNumber: 8,\n            error: errors[8]\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            valid: false,\n            errorNumber: 9,\n            error: errors[9]\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        valid: false,\n        errorNumber: 10,\n        error: errors[10]\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      valid: false,\n      errorNumber: 11,\n      error: errors[11]\n    };\n  }\n  /* everything's okay! */\n  return {\n    valid: true,\n    errorNumber: 0,\n    error: errors[0]\n  };\n}\nexports.validateFen = validateFen;\n/* this function is used to uniquely identify ambiguous moves */\nfunction getDisambiguator(move, moves) {\n  var from = move.from;\n  var to = move.to;\n  var piece = move.piece;\n  var ambiguities = 0;\n  var sameRank = 0;\n  var sameFile = 0;\n  for (var i = 0, len = moves.length; i < len; i++) {\n    var ambigFrom = moves[i].from;\n    var ambigTo = moves[i].to;\n    var ambigPiece = moves[i].piece;\n    /* if a move of the same piece type ends on the same to square, we'll\n     * need to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    /* if there exists a similar moving piece on the same rank and file\n       as the move in question, use the square as the disambiguator\n    */\n    if (sameRank > 0 && sameFile > 0) {\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /* if the moving piece rests on the same file, use the rank symbol\n         as the disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      /* else use the file symbol */\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece) {\n  var captured = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  var flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BITS.NORMAL;\n  var r = rank(to);\n  if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (var i = 0; i < PROMOTIONS.length; i++) {\n      var promotion = PROMOTIONS[i];\n      moves.push({\n        color: color,\n        from: from,\n        to: to,\n        piece: piece,\n        captured: captured,\n        promotion: promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color: color,\n      from: from,\n      to: to,\n      piece: piece,\n      captured: captured,\n      promotion: undefined,\n      flags: flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  var pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    var matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return exports.PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return exports.KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nvar Chess = /*#__PURE__*/function () {\n  function Chess() {\n    var fen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.DEFAULT_POSITION;\n    _classCallCheck(this, Chess);\n    this._board = new Array(128);\n    this._turn = exports.WHITE;\n    this._header = {};\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._epSquare = -1;\n    this._halfMoves = 0;\n    this._moveNumber = 0;\n    this._history = [];\n    this._comments = {};\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this.load(fen);\n  }\n  _createClass(Chess, [{\n    key: \"clear\",\n    value: function clear() {\n      var keepHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._board = new Array(128);\n      this._kings = {\n        w: EMPTY,\n        b: EMPTY\n      };\n      this._turn = exports.WHITE;\n      this._castling = {\n        w: 0,\n        b: 0\n      };\n      this._epSquare = EMPTY;\n      this._halfMoves = 0;\n      this._moveNumber = 1;\n      this._history = [];\n      this._comments = {};\n      this._header = keepHeaders ? this._header : {};\n      this._updateSetup(this.fen());\n    }\n  }, {\n    key: \"load\",\n    value: function load(fen) {\n      var keepHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var tokens = fen.split(/\\s+/);\n      var position = tokens[0];\n      var square = 0;\n      if (!validateFen(fen).valid) {\n        return false;\n      }\n      this.clear(keepHeaders);\n      for (var i = 0; i < position.length; i++) {\n        var piece = position.charAt(i);\n        if (piece === '/') {\n          square += 8;\n        } else if (isDigit(piece)) {\n          square += parseInt(piece, 10);\n        } else {\n          var color = piece < 'a' ? exports.WHITE : exports.BLACK;\n          this.put({\n            type: piece.toLowerCase(),\n            color: color\n          }, algebraic(square));\n          square++;\n        }\n      }\n      this._turn = tokens[1];\n      if (tokens[2].indexOf('K') > -1) {\n        this._castling.w |= BITS.KSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('Q') > -1) {\n        this._castling.w |= BITS.QSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('k') > -1) {\n        this._castling.b |= BITS.KSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('q') > -1) {\n        this._castling.b |= BITS.QSIDE_CASTLE;\n      }\n      this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n      this._halfMoves = parseInt(tokens[4], 10);\n      this._moveNumber = parseInt(tokens[5], 10);\n      this._updateSetup(this.fen());\n      return true;\n    }\n  }, {\n    key: \"fen\",\n    value: function fen() {\n      var empty = 0;\n      var fen = '';\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        if (this._board[i]) {\n          if (empty > 0) {\n            fen += empty;\n            empty = 0;\n          }\n          var _this$_board$i = this._board[i],\n            color = _this$_board$i.color,\n            piece = _this$_board$i.type;\n          fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        } else {\n          empty++;\n        }\n        if (i + 1 & 0x88) {\n          if (empty > 0) {\n            fen += empty;\n          }\n          if (i !== Ox88.h1) {\n            fen += '/';\n          }\n          empty = 0;\n          i += 8;\n        }\n      }\n      var cflags = '';\n      if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n        cflags += 'K';\n      }\n      if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n        cflags += 'Q';\n      }\n      if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n        cflags += 'k';\n      }\n      if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n        cflags += 'q';\n      }\n      /* do we have an empty castling flag? */\n      cflags = cflags || '-';\n      var epflags = this._epSquare === EMPTY ? '-' : algebraic(this._epSquare);\n      return [fen, this._turn, cflags, epflags, this._halfMoves, this._moveNumber].join(' ');\n    }\n    /* Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been  made.\n     */\n  }, {\n    key: \"_updateSetup\",\n    value: function _updateSetup(fen) {\n      if (this._history.length > 0) return;\n      if (fen !== exports.DEFAULT_POSITION) {\n        this._header['SetUp'] = '1';\n        this._header['FEN'] = fen;\n      } else {\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.load(exports.DEFAULT_POSITION);\n    }\n  }, {\n    key: \"get\",\n    value: function get(square) {\n      return this._board[Ox88[square]] || false;\n    }\n  }, {\n    key: \"put\",\n    value: function put(_ref, square) {\n      var type = _ref.type,\n        color = _ref.color;\n      /* check for piece */\n      if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n        return false;\n      }\n      /* check for valid square */\n      if (!(square in Ox88)) {\n        return false;\n      }\n      var sq = Ox88[square];\n      /* don't let the user place more than one king */\n      if (type == exports.KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n        return false;\n      }\n      this._board[sq] = {\n        type: type,\n        color: color\n      };\n      if (type === exports.KING) {\n        this._kings[color] = sq;\n      }\n      this._updateSetup(this.fen());\n      return true;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(square) {\n      var piece = this.get(square);\n      delete this._board[Ox88[square]];\n      if (piece && piece.type === exports.KING) {\n        this._kings[piece.color] = EMPTY;\n      }\n      this._updateSetup(this.fen());\n      return piece;\n    }\n  }, {\n    key: \"_attacked\",\n    value: function _attacked(color, square) {\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        /* did we run off the end of the board */\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n        /* if empty square or wrong color */\n        if (this._board[i] === undefined || this._board[i].color !== color) {\n          continue;\n        }\n        var piece = this._board[i];\n        var difference = i - square;\n        var index = difference + 119;\n        if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n          if (piece.type === exports.PAWN) {\n            if (difference > 0) {\n              if (piece.color === exports.WHITE) return true;\n            } else {\n              if (piece.color === exports.BLACK) return true;\n            }\n            continue;\n          }\n          /* if the piece is a knight or a king */\n          if (piece.type === 'n' || piece.type === 'k') return true;\n          var offset = RAYS[index];\n          var j = i + offset;\n          var blocked = false;\n          while (j !== square) {\n            if (this._board[j] != null) {\n              blocked = true;\n              break;\n            }\n            j += offset;\n          }\n          if (!blocked) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_isKingAttacked\",\n    value: function _isKingAttacked(color) {\n      return this._attacked(swapColor(color), this._kings[color]);\n    }\n  }, {\n    key: \"isCheck\",\n    value: function isCheck() {\n      return this._isKingAttacked(this._turn);\n    }\n  }, {\n    key: \"inCheck\",\n    value: function inCheck() {\n      return this.isCheck();\n    }\n  }, {\n    key: \"isCheckmate\",\n    value: function isCheckmate() {\n      return this.isCheck() && this._moves().length === 0;\n    }\n  }, {\n    key: \"isStalemate\",\n    value: function isStalemate() {\n      return !this.isCheck() && this._moves().length === 0;\n    }\n  }, {\n    key: \"isInsufficientMaterial\",\n    value: function isInsufficientMaterial() {\n      // k.b. vs k.b. (of opposite colors) with mate in 1:\n      // 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n      //\n      // k.b. vs k.n. with mate in 1:\n      // 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n      var pieces = {\n        b: 0,\n        n: 0,\n        r: 0,\n        q: 0,\n        k: 0,\n        p: 0\n      };\n      var bishops = [];\n      var numPieces = 0;\n      var squareColor = 0;\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        squareColor = (squareColor + 1) % 2;\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n        var piece = this._board[i];\n        if (piece) {\n          pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n          if (piece.type === exports.BISHOP) {\n            bishops.push(squareColor);\n          }\n          numPieces++;\n        }\n      }\n      // k vs. k\n      if (numPieces === 2) {\n        return true;\n      } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 && (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n        return true;\n      } else if (numPieces === pieces[exports.BISHOP] + 2) {\n        // kb vs. kb where any number of bishops are all on the same color\n        var sum = 0;\n        var len = bishops.length;\n        for (var _i = 0; _i < len; _i++) {\n          sum += bishops[_i];\n        }\n        if (sum === 0 || sum === len) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"isThreefoldRepetition\",\n    value: function isThreefoldRepetition() {\n      /* TODO: while this function is fine for casual use, a better\n        * implementation would use a Zobrist key (instead of FEN). the\n        * Zobrist key would be maintained in the make_move/undo_move\n        functions,\n        * avoiding the costly that we do below.\n        */\n      var moves = [];\n      var positions = {};\n      var repetition = false;\n      while (true) {\n        var move = this._undoMove();\n        if (!move) break;\n        moves.push(move);\n      }\n      while (true) {\n        /* remove the last two fields in the FEN string, they're not needed\n         * when checking for draw by rep */\n        var fen = this.fen().split(' ').slice(0, 4).join(' ');\n        /* has the position occurred three or move times */\n        positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n        if (positions[fen] >= 3) {\n          repetition = true;\n        }\n        var _move2 = moves.pop();\n        if (!_move2) {\n          break;\n        } else {\n          this._makeMove(_move2);\n        }\n      }\n      return repetition;\n    }\n  }, {\n    key: \"isDraw\",\n    value: function isDraw() {\n      return this._halfMoves >= 100 ||\n      // 50 moves per side = 100 half moves\n      this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n    }\n  }, {\n    key: \"isGameOver\",\n    value: function isGameOver() {\n      return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n  }, {\n    key: \"moves\",\n    value: function moves() {\n      var _this = this;\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$verbose = _ref2.verbose,\n        verbose = _ref2$verbose === void 0 ? false : _ref2$verbose,\n        _ref2$square = _ref2.square,\n        square = _ref2$square === void 0 ? undefined : _ref2$square;\n      var moves = this._moves({\n        square: square\n      });\n      if (verbose) {\n        return moves.map(function (move) {\n          return _this._makePretty(move);\n        });\n      } else {\n        return moves.map(function (move) {\n          return _this._moveToSan(move, moves);\n        });\n      }\n    }\n  }, {\n    key: \"_moves\",\n    value: function _moves() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$legal = _ref3.legal,\n        legal = _ref3$legal === void 0 ? true : _ref3$legal,\n        _ref3$piece = _ref3.piece,\n        piece = _ref3$piece === void 0 ? undefined : _ref3$piece,\n        _ref3$square = _ref3.square,\n        square = _ref3$square === void 0 ? undefined : _ref3$square;\n      var _a;\n      var forSquare = square ? square.toLowerCase() : undefined;\n      var forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n      var moves = [];\n      var us = this._turn;\n      var them = swapColor(us);\n      var firstSquare = Ox88.a8;\n      var lastSquare = Ox88.h1;\n      var singleSquare = false;\n      /* are we generating moves for a single square? */\n      if (forSquare) {\n        // illegal square, return empty moves\n        if (!(forSquare in Ox88)) {\n          return [];\n        } else {\n          firstSquare = lastSquare = Ox88[forSquare];\n          singleSquare = true;\n        }\n      }\n      for (var from = firstSquare; from <= lastSquare; from++) {\n        /* did we run off the end of the board */\n        if (from & 0x88) {\n          from += 7;\n          continue;\n        }\n        // empty square or opponent, skip\n        if (!this._board[from] || this._board[from].color === them) {\n          continue;\n        }\n        var type = this._board[from].type;\n        var to = void 0;\n        if (type === exports.PAWN) {\n          if (forPiece && forPiece !== type) continue;\n          /* single square, non-capturing */\n          to = from + PAWN_OFFSETS[us][0];\n          if (!this._board[to]) {\n            addMove(moves, us, from, to, exports.PAWN);\n            /* double square */\n            to = from + PAWN_OFFSETS[us][1];\n            if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n              addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n            }\n          }\n          /* pawn captures */\n          for (var j = 2; j < 4; j++) {\n            to = from + PAWN_OFFSETS[us][j];\n            if (to & 0x88) continue;\n            if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n              addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n            } else if (to === this._epSquare) {\n              addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n            }\n          }\n        } else {\n          if (forPiece && forPiece !== type) continue;\n          for (var _j = 0, len = PIECE_OFFSETS[type].length; _j < len; _j++) {\n            var offset = PIECE_OFFSETS[type][_j];\n            to = from;\n            while (true) {\n              to += offset;\n              if (to & 0x88) break;\n              if (!this._board[to]) {\n                addMove(moves, us, from, to, type);\n              } else {\n                // own color, stop loop\n                if (this._board[to].color === us) break;\n                addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                break;\n              }\n              /* break, if knight or king */\n              if (type === exports.KNIGHT || type === exports.KING) break;\n            }\n          }\n        }\n      }\n      /* check for castling if:\n       * a) we're generating all moves, or\n       * b) we're doing single square move generation on the king's square\n       */\n      if (forPiece === undefined || forPiece === exports.KING) {\n        if (!singleSquare || lastSquare === this._kings[us]) {\n          /* king-side castling */\n          if (this._castling[us] & BITS.KSIDE_CASTLE) {\n            var castlingFrom = this._kings[us];\n            var castlingTo = castlingFrom + 2;\n            if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n              addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n            }\n          }\n          /* queen-side castling */\n          if (this._castling[us] & BITS.QSIDE_CASTLE) {\n            var _castlingFrom = this._kings[us];\n            var _castlingTo = _castlingFrom - 2;\n            if (!this._board[_castlingFrom - 1] && !this._board[_castlingFrom - 2] && !this._board[_castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, _castlingFrom - 1) && !this._attacked(them, _castlingTo)) {\n              addMove(moves, us, this._kings[us], _castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n            }\n          }\n        }\n      }\n      /* return all pseudo-legal moves (this includes moves that allow the king\n       * to be captured) */\n      if (!legal) {\n        return moves;\n      }\n      /* filter out illegal moves */\n      var legalMoves = [];\n      for (var i = 0, _len = moves.length; i < _len; i++) {\n        this._makeMove(moves[i]);\n        if (!this._isKingAttacked(us)) {\n          legalMoves.push(moves[i]);\n        }\n        this._undoMove();\n      }\n      return legalMoves;\n    }\n  }, {\n    key: \"move\",\n    value: function move(_move) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref4$sloppy = _ref4.sloppy,\n        sloppy = _ref4$sloppy === void 0 ? false : _ref4$sloppy;\n      /* The move function can be called with in the following parameters:\n          *\n          * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n          *\n          * .move({ from: 'h7', <- where the 'move' is a move object\n          (additional\n          *         to :'h8',      fields are ignored)\n          *         promotion: 'q',\n          *      })\n          */\n      // sloppy parser allows the move parser to work around over disambiguation\n      // bugs in Fritz and Chessbase\n      var moveObj = null;\n      if (typeof _move === 'string') {\n        moveObj = this._moveFromSan(_move, sloppy);\n      } else if (typeof _move === 'object') {\n        var moves = this._moves();\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (_move.from === algebraic(moves[i].from) && _move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || _move.promotion === moves[i].promotion)) {\n            moveObj = moves[i];\n            break;\n          }\n        }\n      }\n      /* failed to find move */\n      if (!moveObj) {\n        return null;\n      }\n      /* need to make a copy of move because we can't generate SAN after\n         the move is made */\n      var prettyMove = this._makePretty(moveObj);\n      this._makeMove(moveObj);\n      return prettyMove;\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(move) {\n      this._history.push({\n        move: move,\n        kings: {\n          b: this._kings.b,\n          w: this._kings.w\n        },\n        turn: this._turn,\n        castling: {\n          b: this._castling.b,\n          w: this._castling.w\n        },\n        epSquare: this._epSquare,\n        halfMoves: this._halfMoves,\n        moveNumber: this._moveNumber\n      });\n    }\n  }, {\n    key: \"_makeMove\",\n    value: function _makeMove(move) {\n      var us = this._turn;\n      var them = swapColor(us);\n      this._push(move);\n      this._board[move.to] = this._board[move.from];\n      delete this._board[move.from];\n      /* if ep capture, remove the captured pawn */\n      if (move.flags & BITS.EP_CAPTURE) {\n        if (this._turn === exports.BLACK) {\n          delete this._board[move.to - 16];\n        } else {\n          delete this._board[move.to + 16];\n        }\n      }\n      /* if pawn promotion, replace with new piece */\n      if (move.promotion) {\n        this._board[move.to] = {\n          type: move.promotion,\n          color: us\n        };\n      }\n      /* if we moved the king */\n      if (this._board[move.to].type === exports.KING) {\n        this._kings[us] = move.to;\n        /* if we castled, move the rook next to the king */\n        if (move.flags & BITS.KSIDE_CASTLE) {\n          var castlingTo = move.to - 1;\n          var castlingFrom = move.to + 1;\n          this._board[castlingTo] = this._board[castlingFrom];\n          delete this._board[castlingFrom];\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\n          var _castlingTo2 = move.to + 1;\n          var _castlingFrom2 = move.to - 2;\n          this._board[_castlingTo2] = this._board[_castlingFrom2];\n          delete this._board[_castlingFrom2];\n        }\n        /* turn off castling */\n        this._castling[us] = 0;\n      }\n      /* turn off castling if we move a rook */\n      if (this._castling[us]) {\n        for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n          if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n            this._castling[us] ^= ROOKS[us][i].flag;\n            break;\n          }\n        }\n      }\n      /* turn off castling if we capture a rook */\n      if (this._castling[them]) {\n        for (var _i2 = 0, _len2 = ROOKS[them].length; _i2 < _len2; _i2++) {\n          if (move.to === ROOKS[them][_i2].square && this._castling[them] & ROOKS[them][_i2].flag) {\n            this._castling[them] ^= ROOKS[them][_i2].flag;\n            break;\n          }\n        }\n      }\n      /* if big pawn move, update the en passant square */\n      if (move.flags & BITS.BIG_PAWN) {\n        if (us === exports.BLACK) {\n          this._epSquare = move.to - 16;\n        } else {\n          this._epSquare = move.to + 16;\n        }\n      } else {\n        this._epSquare = EMPTY;\n      }\n      /* reset the 50 move counter if a pawn is moved or a piece is captured */\n      if (move.piece === exports.PAWN) {\n        this._halfMoves = 0;\n      } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        this._halfMoves = 0;\n      } else {\n        this._halfMoves++;\n      }\n      if (us === exports.BLACK) {\n        this._moveNumber++;\n      }\n      this._turn = them;\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      var move = this._undoMove();\n      return move ? this._makePretty(move) : null;\n    }\n  }, {\n    key: \"_undoMove\",\n    value: function _undoMove() {\n      var old = this._history.pop();\n      if (old === undefined) {\n        return null;\n      }\n      var move = old.move;\n      this._kings = old.kings;\n      this._turn = old.turn;\n      this._castling = old.castling;\n      this._epSquare = old.epSquare;\n      this._halfMoves = old.halfMoves;\n      this._moveNumber = old.moveNumber;\n      var us = this._turn;\n      var them = swapColor(us);\n      this._board[move.from] = this._board[move.to];\n      this._board[move.from].type = move.piece; // to undo any promotions\n      delete this._board[move.to];\n      if (move.captured) {\n        if (move.flags & BITS.EP_CAPTURE) {\n          // en passant capture\n          var index;\n          if (us === exports.BLACK) {\n            index = move.to - 16;\n          } else {\n            index = move.to + 16;\n          }\n          this._board[index] = {\n            type: exports.PAWN,\n            color: them\n          };\n        } else {\n          // regular capture\n          this._board[move.to] = {\n            type: move.captured,\n            color: them\n          };\n        }\n      }\n      if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n        var castlingTo, castlingFrom;\n        if (move.flags & BITS.KSIDE_CASTLE) {\n          castlingTo = move.to + 1;\n          castlingFrom = move.to - 1;\n        } else {\n          castlingTo = move.to - 2;\n          castlingFrom = move.to + 1;\n        }\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      return move;\n    }\n  }, {\n    key: \"pgn\",\n    value: function pgn() {\n      var _this2 = this;\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref5$newline = _ref5.newline,\n        newline = _ref5$newline === void 0 ? '\\n' : _ref5$newline,\n        _ref5$maxWidth = _ref5.maxWidth,\n        maxWidth = _ref5$maxWidth === void 0 ? 0 : _ref5$maxWidth;\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var result = [];\n      var headerExists = false;\n      /* add the PGN header information */\n      for (var i in this._header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n        headerExists = true;\n      }\n      if (headerExists && this._history.length) {\n        result.push(newline);\n      }\n      var appendComment = function appendComment(moveString) {\n        var comment = _this2._comments[_this2.fen()];\n        if (typeof comment !== 'undefined') {\n          var delimiter = moveString.length > 0 ? ' ' : '';\n          moveString = \"\".concat(moveString).concat(delimiter, \"{\").concat(comment, \"}\");\n        }\n        return moveString;\n      };\n      /* pop all of history onto reversed_history */\n      var reversedHistory = [];\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      var moves = [];\n      var moveString = '';\n      /* special case of a commented starting position with no moves */\n      if (reversedHistory.length === 0) {\n        moves.push(appendComment(''));\n      }\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversedHistory.length > 0) {\n        moveString = appendComment(moveString);\n        var move = reversedHistory.pop();\n        // make TypeScript stop complaining about move being undefined\n        if (!move) {\n          break;\n        }\n        /* if the position started with black to move, start PGN with #. ... */\n        if (!this._history.length && move.color === 'b') {\n          var prefix = \"\".concat(this._moveNumber, \". ...\");\n          /* is there a comment preceding the first move? */\n          moveString = moveString ? \"\".concat(moveString, \" \").concat(prefix) : prefix;\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (moveString.length) {\n            moves.push(moveString);\n          }\n          moveString = this._moveNumber + '.';\n        }\n        moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n          legal: true\n        }));\n        this._makeMove(move);\n      }\n      /* are there any other leftover moves? */\n      if (moveString.length) {\n        moves.push(appendComment(moveString));\n      }\n      /* is there a result? */\n      if (typeof this._header.Result !== 'undefined') {\n        moves.push(this._header.Result);\n      }\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (maxWidth === 0) {\n        return result.join('') + moves.join(' ');\n      }\n      // JAH: huh?\n      var strip = function strip() {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n        return false;\n      };\n      /* NB: this does not preserve comment whitespace. */\n      var wrapComment = function wrapComment(width, move) {\n        var _iterator = _createForOfIteratorHelper(move.split(' ')),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var token = _step.value;\n            if (!token) {\n              continue;\n            }\n            if (width + token.length > maxWidth) {\n              while (strip()) {\n                width--;\n              }\n              result.push(newline);\n              width = 0;\n            }\n            result.push(token);\n            width += token.length;\n            result.push(' ');\n            width++;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (strip()) {\n          width--;\n        }\n        return width;\n      };\n      /* wrap the PGN output at max_width */\n      var currentWidth = 0;\n      for (var _i3 = 0; _i3 < moves.length; _i3++) {\n        if (currentWidth + moves[_i3].length > maxWidth) {\n          if (moves[_i3].includes('{')) {\n            currentWidth = wrapComment(currentWidth, moves[_i3]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n        if (currentWidth + moves[_i3].length > maxWidth && _i3 !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n          result.push(newline);\n          currentWidth = 0;\n        } else if (_i3 !== 0) {\n          result.push(' ');\n          currentWidth++;\n        }\n        result.push(moves[_i3]);\n        currentWidth += moves[_i3].length;\n      }\n      return result.join('');\n    }\n  }, {\n    key: \"header\",\n    value: function header() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key = 0; _key < _len3; _key++) {\n        args[_key] = arguments[_key];\n      }\n      for (var i = 0; i < args.length; i += 2) {\n        if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n          this._header[args[i]] = args[i + 1];\n        }\n      }\n      return this._header;\n    }\n  }, {\n    key: \"loadPgn\",\n    value: function loadPgn(pgn) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref6$sloppy = _ref6.sloppy,\n        sloppy = _ref6$sloppy === void 0 ? false : _ref6$sloppy,\n        _ref6$newlineChar = _ref6.newlineChar,\n        newlineChar = _ref6$newlineChar === void 0 ? '\\r?\\n' : _ref6$newlineChar;\n      // option sloppy=true\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n      function parsePgnHeader(header) {\n        var headerObj = {};\n        var headers = header.split(new RegExp(mask(newlineChar)));\n        var key = '';\n        var value = '';\n        for (var i = 0; i < headers.length; i++) {\n          var regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n          key = headers[i].replace(regex, '$1');\n          value = headers[i].replace(regex, '$2');\n          if (key.trim().length > 0) {\n            headerObj[key] = value;\n          }\n        }\n        return headerObj;\n      }\n      // strip whitespace from head/tail of PGN block\n      pgn = pgn.trim();\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n      var headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '(?:\\\\s*' + mask(newlineChar) + '){2}');\n      // If no header given, begin with moves.\n      var headerRegexResults = headerRegex.exec(pgn);\n      var headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n      // Put the board in the starting position\n      this.reset();\n      /* parse PGN header */\n      var headers = parsePgnHeader(headerString);\n      var fen = '';\n      for (var key in headers) {\n        // check to see user is including fen (possibly with wrong tag case)\n        if (key.toLowerCase() === 'fen') {\n          fen = headers[key];\n        }\n        this.header(key, headers[key]);\n      }\n      /* sloppy parser should attempt to load a fen tag, even if it's\n       * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n      if (sloppy) {\n        if (fen) {\n          if (!this.load(fen, true)) {\n            return false;\n          }\n        }\n      } else {\n        /* strict parser - load the starting position indicated by [Setup '1']\n         * and [FEN position] */\n        if (headers['SetUp'] === '1') {\n          if (!('FEN' in headers && this.load(headers['FEN'], true))) {\n            // second argument to load: don't clear the headers\n            return false;\n          }\n        }\n      }\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n      function toHex(s) {\n        return Array.from(s).map(function (c) {\n          /* encodeURI doesn't transform most ASCII characters,\n           * so we handle these ourselves */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n        }).join('');\n      }\n      function fromHex(s) {\n        return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n      }\n      var encodeComment = function encodeComment(s) {\n        s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        return \"{\".concat(toHex(s.slice(1, s.length - 1)), \"}\");\n      };\n      var decodeComment = function decodeComment(s) {\n        if (s.startsWith('{') && s.endsWith('}')) {\n          return fromHex(s.slice(1, s.length - 1));\n        }\n      };\n      /* delete header to get the moves */\n      var ms = pgn.replace(headerString, '').replace( /* encode comments so they don't get deleted below */\n      new RegExp(\"({[^}]*})+?|;([^\".concat(mask(newlineChar), \"]*)\"), 'g'), function (_match, bracket, semicolon) {\n        return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(\"{\".concat(semicolon.slice(1), \"}\"));\n      }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      /* delete recursive annotation variations */\n      var ravRegex = /(\\([^()]+\\))+?/g;\n      while (ravRegex.test(ms)) {\n        ms = ms.replace(ravRegex, '');\n      }\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '');\n      /* trim and get array of moves */\n      var moves = ms.trim().split(new RegExp(/\\s+/));\n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var result = '';\n      for (var halfMove = 0; halfMove < moves.length; halfMove++) {\n        var comment = decodeComment(moves[halfMove]);\n        if (comment !== undefined) {\n          this._comments[this.fen()] = comment;\n          continue;\n        }\n        var move = this._moveFromSan(moves[halfMove], sloppy);\n        /* invalid move */\n        if (move == null) {\n          /* was the move an end of game marker */\n          if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n            result = moves[halfMove];\n          } else {\n            return false;\n          }\n        } else {\n          /* reset the end of game marker if making a valid move */\n          result = '';\n          this._makeMove(move);\n        }\n      }\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n      * match the termination marker. Only do this when headers are\n          present,\n          * but the result tag is missing\n          */\n      if (result && Object.keys(this._header).length && !this._header['Result']) {\n        this.header('Result', result);\n      }\n      return true;\n    }\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n      * (SAN)\n      *\n      * @param {boolean} sloppy Use the sloppy SAN generator to work around\n      over\n      * disambiguation bugs in Fritz and Chessbase.  See below:\n      *\n      * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n      * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n      * 4. ... Ne7 is technically the valid SAN\n      */\n  }, {\n    key: \"_moveToSan\",\n    value: function _moveToSan(move, moves) {\n      var output = '';\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        output = 'O-O';\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        output = 'O-O-O';\n      } else {\n        if (move.piece !== exports.PAWN) {\n          var disambiguator = getDisambiguator(move, moves);\n          output += move.piece.toUpperCase() + disambiguator;\n        }\n        if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n          if (move.piece === exports.PAWN) {\n            output += algebraic(move.from)[0];\n          }\n          output += 'x';\n        }\n        output += algebraic(move.to);\n        if (move.promotion) {\n          output += '=' + move.promotion.toUpperCase();\n        }\n      }\n      this._makeMove(move);\n      if (this.isCheck()) {\n        if (this.isCheckmate()) {\n          output += '#';\n        } else {\n          output += '+';\n        }\n      }\n      this._undoMove();\n      return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88\n    // coordinates\n  }, {\n    key: \"_moveFromSan\",\n    value: function _moveFromSan(move) {\n      var sloppy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // strip off any move decorations: e.g Nf3+?! becomes Nf3\n      var cleanMove = strippedSan(move);\n      var pieceType = inferPieceType(cleanMove);\n      var moves = this._moves({\n        legal: true,\n        piece: pieceType\n      });\n      // strict parser\n      for (var i = 0, len = moves.length; i < len; i++) {\n        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n          return moves[i];\n        }\n      }\n      // strict parser failed and the sloppy parser wasn't used, return null\n      if (!sloppy) {\n        return null;\n      }\n      var piece = undefined;\n      var matches = undefined;\n      var from = undefined;\n      var to = undefined;\n      var promotion = undefined;\n      // The sloppy parser allows the user to parse non-standard chess\n      // notations. This parser is opt-in (by specifying the\n      // '{ sloppy: true }' setting) and is only run after the Standard\n      // Algebraic Notation (SAN) parser has failed.\n      //\n      // When running the sloppy parser, we'll run a regex to grab the piece,\n      // the to/from square, and an optional promotion piece. This regex will\n      // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n      // f7f8q, b1c3\n      // NOTE: Some positions and moves may be ambiguous when using the\n      // sloppy parser. For example, in this position:\n      // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n      // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n      // sloppy parser will default to the most most basic interpretation\n      // (which is b1c3 parsing to Nc3).\n      // FIXME: these var's are hoisted into function scope, this will need\n      // to change when switching to const/let\n      var overlyDisambiguated = false;\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      //     piece         from              to       promotion\n      );\n\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      } else {\n        // The [a-h]?[1-8]? portion of the regex below handles moves that may\n        // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n        // when there is one legal knight move to e7). In this case, the value\n        // of 'from' variable will be a rank or file, not a square.\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n          piece = matches[1];\n          from = matches[2];\n          to = matches[3];\n          promotion = matches[4];\n          if (from.length == 1) {\n            overlyDisambiguated = true;\n          }\n        }\n      }\n      pieceType = inferPieceType(cleanMove);\n      moves = this._moves({\n        legal: true,\n        piece: piece ? piece : pieceType\n      });\n      for (var _i4 = 0, _len4 = moves.length; _i4 < _len4; _i4++) {\n        if (from && to) {\n          // hand-compare move properties with the results from our sloppy\n          // regex\n          if ((!piece || piece.toLowerCase() == moves[_i4].piece) && Ox88[from] == moves[_i4].from && Ox88[to] == moves[_i4].to && (!promotion || promotion.toLowerCase() == moves[_i4].promotion)) {\n            return moves[_i4];\n          } else if (overlyDisambiguated) {\n            // SPECIAL CASE: we parsed a move string that may have an\n            // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n            // variable will\n            var square = algebraic(moves[_i4].from);\n            if ((!piece || piece.toLowerCase() == moves[_i4].piece) && Ox88[to] == moves[_i4].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[_i4].promotion)) {\n              return moves[_i4];\n            }\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"ascii\",\n    value: function ascii() {\n      var s = '   +------------------------+\\n';\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        /* display the rank */\n        if (file(i) === 0) {\n          s += ' ' + '87654321'[rank(i)] + ' |';\n        }\n        if (this._board[i]) {\n          var piece = this._board[i].type;\n          var color = this._board[i].color;\n          var symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n          s += ' ' + symbol + ' ';\n        } else {\n          s += ' . ';\n        }\n        if (i + 1 & 0x88) {\n          s += '|\\n';\n          i += 8;\n        }\n      }\n      s += '   +------------------------+\\n';\n      s += '     a  b  c  d  e  f  g  h';\n      return s;\n    }\n  }, {\n    key: \"perft\",\n    value: function perft(depth) {\n      var moves = this._moves({\n        legal: false\n      });\n      var nodes = 0;\n      var color = this._turn;\n      for (var i = 0, len = moves.length; i < len; i++) {\n        this._makeMove(moves[i]);\n        if (!this._isKingAttacked(color)) {\n          if (depth - 1 > 0) {\n            nodes += this.perft(depth - 1);\n          } else {\n            nodes++;\n          }\n        }\n        this._undoMove();\n      }\n      return nodes;\n    }\n    /* pretty = external move object */\n  }, {\n    key: \"_makePretty\",\n    value: function _makePretty(uglyMove) {\n      var color = uglyMove.color,\n        piece = uglyMove.piece,\n        from = uglyMove.from,\n        to = uglyMove.to,\n        flags = uglyMove.flags,\n        captured = uglyMove.captured,\n        promotion = uglyMove.promotion;\n      var prettyFlags = '';\n      for (var flag in BITS) {\n        if (BITS[flag] & flags) {\n          prettyFlags += FLAGS[flag];\n        }\n      }\n      var move = {\n        color: color,\n        piece: piece,\n        from: algebraic(from),\n        to: algebraic(to),\n        san: this._moveToSan(uglyMove, this._moves({\n          legal: true\n        })),\n        flags: prettyFlags\n      };\n      if (captured) {\n        move.captured = captured;\n      }\n      if (promotion) {\n        move.promotion = promotion;\n      }\n      return move;\n    }\n  }, {\n    key: \"turn\",\n    value: function turn() {\n      return this._turn;\n    }\n  }, {\n    key: \"board\",\n    value: function board() {\n      var output = [];\n      var row = [];\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        if (this._board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            square: algebraic(i),\n            type: this._board[i].type,\n            color: this._board[i].color\n          });\n        }\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n      return output;\n    }\n  }, {\n    key: \"squareColor\",\n    value: function squareColor(square) {\n      if (square in Ox88) {\n        var sq = Ox88[square];\n        return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n      }\n      return null;\n    }\n  }, {\n    key: \"history\",\n    value: function history() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref7$verbose = _ref7.verbose,\n        verbose = _ref7$verbose === void 0 ? false : _ref7$verbose;\n      var reversedHistory = [];\n      var moveHistory = [];\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      while (true) {\n        var move = reversedHistory.pop();\n        if (!move) {\n          break;\n        }\n        if (verbose) {\n          moveHistory.push(this._makePretty(move));\n        } else {\n          moveHistory.push(this._moveToSan(move, this._moves()));\n        }\n        this._makeMove(move);\n      }\n      return moveHistory;\n    }\n  }, {\n    key: \"_pruneComments\",\n    value: function _pruneComments() {\n      var _this3 = this;\n      var reversedHistory = [];\n      var currentComments = {};\n      var copyComment = function copyComment(fen) {\n        if (fen in _this3._comments) {\n          currentComments[fen] = _this3._comments[fen];\n        }\n      };\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      copyComment(this.fen());\n      while (true) {\n        var move = reversedHistory.pop();\n        if (!move) {\n          break;\n        }\n        this._makeMove(move);\n        copyComment(this.fen());\n      }\n      this._comments = currentComments;\n    }\n  }, {\n    key: \"getComment\",\n    value: function getComment() {\n      return this._comments[this.fen()];\n    }\n  }, {\n    key: \"setComment\",\n    value: function setComment(comment) {\n      this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n  }, {\n    key: \"deleteComment\",\n    value: function deleteComment() {\n      var comment = this._comments[this.fen()];\n      delete this._comments[this.fen()];\n      return comment;\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments() {\n      var _this4 = this;\n      this._pruneComments();\n      return Object.keys(this._comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: _this4._comments[fen]\n        };\n      });\n    }\n  }, {\n    key: \"deleteComments\",\n    value: function deleteComments() {\n      var _this5 = this;\n      this._pruneComments();\n      return Object.keys(this._comments).map(function (fen) {\n        var comment = _this5._comments[fen];\n        delete _this5._comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  }]);\n  return Chess;\n}();\nexports.Chess = Chess;\n//   return {\n//     /***************************************************************************\n//      * PUBLIC CONSTANTS (is there a better way to do this?)\n//      **************************************************************************/\n//     SQUARES: (function () {\n//       /* from the ECMA-262 spec (section 12.6.4):\n//        * \"The mechanics of enumerating the properties ... is\n//        * implementation dependent\"\n//        * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n//        * ordered correctly\n//        */\n//       var keys = []\n//       for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n//         if (i & 0x88) {\n//           i += 7\n//           continue\n//         }\n//         keys.push(algebraic(i))\n//       }\n//       return keys\n//     })(),\n//     FLAGS: FLAGS,\n// }","map":{"version":3,"names":["Object","defineProperty","exports","value","Chess","validateFen","SQUARES","DEFAULT_POSITION","KING","QUEEN","ROOK","BISHOP","KNIGHT","PAWN","BLACK","WHITE","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","fen","errors","tokens","split","length","valid","errorNumber","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","captured","undefined","flags","promotion","push","inferPieceType","san","pieceType","matches","match","toLowerCase","strippedSan","replace","_board","Array","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","load","keepHeaders","_updateSetup","position","clear","put","type","empty","toUpperCase","cflags","epflags","join","sq","get","difference","index","offset","j","blocked","_attacked","_isKingAttacked","isCheck","_moves","pieces","bishops","numPieces","squareColor","sum","positions","repetition","_undoMove","slice","pop","_makeMove","isStalemate","isInsufficientMaterial","isThreefoldRepetition","isCheckmate","isDraw","verbose","map","_makePretty","_moveToSan","legal","_a","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","sloppy","moveObj","_moveFromSan","prettyMove","kings","turn","castling","epSquare","_push","old","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","args","pgn","newlineChar","mask","str","parsePgnHeader","header","headerObj","headers","RegExp","key","regex","trim","headerRegex","headerRegexResults","exec","headerString","reset","toHex","s","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","halfMove","keys","output","disambiguator","cleanMove","overlyDisambiguated","symbol","depth","nodes","perft","uglyMove","prettyFlags","row","moveHistory","currentComments","copyComment","_pruneComments"],"sources":["C:/Users/catas/Desktop/Basic Chess Game/client/node_modules/chess.js/dist/chess.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\n/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexports.SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n// NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n// ----------------------------------------------------------------------------\n// From https://github.com/jhlywa/chess.js/issues/230\n//\n// A lot of people are confused when they first see the internal representation\n// of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n// stores the board as an 8x16 array. This is purely for efficiency but has a\n// couple of interesting benefits:\n//\n// 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n//    square with 0x88, if the result is non-zero then the square is off the\n//    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n//    there are 8 possible directions in which the knight can move. These\n//    directions are relative to the 8x16 board and are stored in the\n//    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n//    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n//    (because of two-complement representation of -18). The non-zero result\n//    means the square is off the board and the move is illegal. Take the\n//    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n//    means the square is on the board.\n//\n// 2. The relative distance (or difference) between two squares on a 8x16 board\n//    is unique and can be used to inexpensively determine if a piece on a\n//    square can attack any other arbitrary square. For example, let's see if a\n//    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n//    -80. We add 119 to make the ATTACKS array index non-negative (because the\n//    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n//    bitmask of pieces that can attack from that distance and direction.\n//    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n//    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n//    example, we would check to see if 24 & 0x1 is non-zero, which it is\n//    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n//    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n//    there are no blocking pieces between E7 and E2. That's where the RAYS\n//    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n//    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n// prettier-ignore\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n// const RANK_3 = 5\n// const RANK_4 = 4\n// const RANK_5 = 3\n// const RANK_6 = 2\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n/**\n * Extracts the zero-based rank of an 0x88 square.\n */\nfunction rank(square) {\n    return square >> 4;\n}\n/**\n * Extracts the zero-based file of an 0x88 square.\n */\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n/**\n * Converts a 0x88 square to algebraic notation.\n */\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n/* TODO: this needs a bit of work - it validates structure but completely\n * ignores content (e.g. doesn't verify that each side has a king) ... we should\n * rewrite this, and ditch the silly error_number field while we're at it */\nfunction validateFen(fen) {\n    const errors = [];\n    errors[0] = 'No errors.';\n    errors[1] = 'FEN string must contain six space-delimited fields.';\n    errors[2] = '6th field (move number) must be a positive integer.';\n    errors[3] = '5th field (half move counter) must be a non-negative integer.';\n    errors[4] = '4th field (en-passant square) is invalid.';\n    errors[5] = '3rd field (castling availability) is invalid.';\n    errors[6] = '2nd field (side to move) is invalid.';\n    errors[7] =\n        \"1st field (piece positions) does not contain 8 '/'-delimited rows.\";\n    errors[8] = '1st field (piece positions) is invalid [consecutive numbers].';\n    errors[9] = '1st field (piece positions) is invalid [invalid piece].';\n    errors[10] = '1st field (piece positions) is invalid [row too large].';\n    errors[11] = 'Illegal en-passant square';\n    /* 1st criterion: 6 space-seperated fields? */\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return { valid: false, errorNumber: 1, error: errors[1] };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return { valid: false, errorNumber: 2, error: errors[2] };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return { valid: false, errorNumber: 3, error: errors[3] };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { valid: false, errorNumber: 4, error: errors[4] };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n        return { valid: false, errorNumber: 5, error: errors[5] };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { valid: false, errorNumber: 6, error: errors[6] };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return { valid: false, errorNumber: 7, error: errors[7] };\n    }\n    /* 8th criterion: every row is valid? */\n    for (let i = 0; i < rows.length; i++) {\n        /* check for right sum of fields AND not two numbers in succession */\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return { valid: false, errorNumber: 8, error: errors[8] };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return { valid: false, errorNumber: 9, error: errors[9] };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return { valid: false, errorNumber: 10, error: errors[10] };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { valid: false, errorNumber: 11, error: errors[11] };\n    }\n    /* everything's okay! */\n    return { valid: true, errorNumber: 0, error: errors[0] };\n}\nexports.validateFen = validateFen;\n/* this function is used to uniquely identify ambiguous moves */\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /* if a move of the same piece type ends on the same to square, we'll\n         * need to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        /* if there exists a similar moving piece on the same rank and file\n           as the move in question, use the square as the disambiguator\n        */\n        if (sameRank > 0 && sameFile > 0) {\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /* if the moving piece rests on the same file, use the rank symbol\n               as the disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            /* else use the file symbol */\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            promotion: undefined,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return exports.PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return exports.KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    constructor(fen = exports.DEFAULT_POSITION) {\n        this._board = new Array(128);\n        this._turn = exports.WHITE;\n        this._header = {};\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = { w: 0, b: 0 };\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = exports.WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    load(fen, keepHeaders = false) {\n        const tokens = fen.split(/\\s+/);\n        const position = tokens[0];\n        let square = 0;\n        if (!validateFen(fen).valid) {\n            return false;\n        }\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n        return true;\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let cflags = '';\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n            cflags += 'K';\n        }\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n            cflags += 'Q';\n        }\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n            cflags += 'k';\n        }\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n            cflags += 'q';\n        }\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-';\n        const epflags = this._epSquare === EMPTY ? '-' : algebraic(this._epSquare);\n        return [\n            fen,\n            this._turn,\n            cflags,\n            epflags,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /* Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been  made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== exports.DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(exports.DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        /* check for piece */\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        /* check for valid square */\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        /* don't let the user place more than one king */\n        if (type == exports.KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === exports.KING) {\n            this._kings[color] = sq;\n        }\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === exports.KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            /* if empty square or wrong color */\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === exports.PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === exports.WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === exports.BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        return this._attacked(swapColor(color), this._kings[color]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        // k.b. vs k.b. (of opposite colors) with mate in 1:\n        // 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n        //\n        // k.b. vs k.n. with mate in 1:\n        // 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === exports.BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        /* TODO: while this function is fine for casual use, a better\n          * implementation would use a Zobrist key (instead of FEN). the\n          * Zobrist key would be maintained in the make_move/undo_move\n          functions,\n          * avoiding the costly that we do below.\n          */\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            /* has the position occurred three or move times */\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, } = {}) {\n        const moves = this._moves({ square });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        var _a;\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        /* are we generating moves for a single square? */\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            /* did we run off the end of the board */\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === exports.PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                /* single square, non-capturing */\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, exports.PAWN);\n                    /* double square */\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                /* pawn captures */\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === exports.KNIGHT || type === exports.KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /* check for castling if:\n         * a) we're generating all moves, or\n         * b) we're doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === exports.KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                /* king-side castling */\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                /* queen-side castling */\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured) */\n        if (!legal) {\n            return moves;\n        }\n        /* filter out illegal moves */\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { sloppy = false } = {}) {\n        /* The move function can be called with in the following parameters:\n            *\n            * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n            *\n            * .move({ from: 'h7', <- where the 'move' is a move object\n            (additional\n            *         to :'h8',      fields are ignored)\n            *         promotion: 'q',\n            *      })\n            */\n        // sloppy parser allows the move parser to work around over disambiguation\n        // bugs in Fritz and Chessbase\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, sloppy);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            /* convert the pretty move object to an ugly move object */\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        /* failed to find move */\n        if (!moveObj) {\n            return null;\n        }\n        /* need to make a copy of move because we can't generate SAN after\n           the move is made */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === exports.BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        /* if pawn promotion, replace with new piece */\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        /* if we moved the king */\n        if (this._board[move.to].type === exports.KING) {\n            this._kings[us] = move.to;\n            /* if we castled, move the rook next to the king */\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            /* turn off castling */\n            this._castling[us] = 0;\n        }\n        /* turn off castling if we move a rook */\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        /* turn off castling if we capture a rook */\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        /* if big pawn move, update the en passant square */\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === exports.BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === exports.PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === exports.BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === exports.BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: exports.PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /* TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        /* pop all of history onto reversed_history */\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        /* special case of a commented starting position with no moves */\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            /* if the position started with black to move, start PGN with #. ... */\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                /* is there a comment preceding the first move? */\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                /* store the previous generated move_string if we have one */\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        /* are there any other leftover moves? */\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        /* is there a result? */\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /* history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // JAH: huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        /* NB: this does not preserve comment whitespace. */\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        /* wrap the PGN output at max_width */\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            /* if the current move will push past max_width */\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                /* don't end the line with whitespace */\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { sloppy = false, newlineChar = '\\r?\\n', } = {}) {\n        // option sloppy=true\n        // allow the user to specify the sloppy move parser to work around over\n        // disambiguation bugs in Fritz and Chessbase\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        // RegExp to split header. Takes advantage of the fact that header and movetext\n        // will always have a blank line between them (ie, two newline_char's).\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '(?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        /* parse PGN header */\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /* sloppy parser should attempt to load a fen tag, even if it's\n         * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n        if (sloppy) {\n            if (fen) {\n                if (!this.load(fen, true)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            /* strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position] */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers && this.load(headers['FEN'], true))) {\n                    // second argument to load: don't clear the headers\n                    return false;\n                }\n            }\n        }\n        /* NB: the regexes below that delete move numbers, recursive\n         * annotations, and numeric annotation glyphs may also match\n         * text in comments. To prevent this, we transform comments\n         * by hex-encoding them in place and decoding them again after\n         * the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded,\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\n         * as a convenience for modern users */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /* encodeURI doesn't transform most ASCII characters,\n                 * so we handle these ourselves */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        /* delete header to get the moves */\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        /* encode comments so they don't get deleted below */\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        /* delete recursive annotation variations */\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        /* delete move numbers */\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        /* delete ... indicating black to move */\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        /* trim and get array of moves */\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        /* delete empty entries */\n        moves = moves.join(',').replace(/,,+/g, ',').split(',');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], sloppy);\n            /* invalid move */\n            if (move == null) {\n                /* was the move an end of game marker */\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                /* reset the end of game marker if making a valid move */\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n    * match the termination marker. Only do this when headers are\n            present,\n            * but the result tag is missing\n            */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n        return true;\n    }\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n      * (SAN)\n      *\n      * @param {boolean} sloppy Use the sloppy SAN generator to work around\n      over\n      * disambiguation bugs in Fritz and Chessbase.  See below:\n      *\n      * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n      * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n      * 4. ... Ne7 is technically the valid SAN\n      */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== exports.PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === exports.PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88\n    // coordinates\n    _moveFromSan(move, sloppy = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // strict parser failed and the sloppy parser wasn't used, return null\n        if (!sloppy) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        // The sloppy parser allows the user to parse non-standard chess\n        // notations. This parser is opt-in (by specifying the\n        // '{ sloppy: true }' setting) and is only run after the Standard\n        // Algebraic Notation (SAN) parser has failed.\n        //\n        // When running the sloppy parser, we'll run a regex to grab the piece,\n        // the to/from square, and an optional promotion piece. This regex will\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n        // f7f8q, b1c3\n        // NOTE: Some positions and moves may be ambiguous when using the\n        // sloppy parser. For example, in this position:\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n        // sloppy parser will default to the most most basic interpretation\n        // (which is b1c3 parsing to Nc3).\n        // FIXME: these var's are hoisted into function scope, this will need\n        // to change when switching to const/let\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            // The [a-h]?[1-8]? portion of the regex below handles moves that may\n            // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n            // when there is one legal knight move to e7). In this case, the value\n            // of 'from' variable will be a rank or file, not a square.\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (from && to) {\n                // hand-compare move properties with the results from our sloppy\n                // regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[from] == moves[i].from &&\n                    Ox88[to] == moves[i].to &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n                else if (overlyDisambiguated) {\n                    // SPECIAL CASE: we parsed a move string that may have an\n                    // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                    // variable will\n                    const square = algebraic(moves[i].from);\n                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                        Ox88[to] == moves[i].to &&\n                        (from == square[0] || from == square[1]) &&\n                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                        return moves[i];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            /* display the rank */\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    /* pretty = external move object */\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const move = {\n            color,\n            piece,\n            from: algebraic(from),\n            to: algebraic(to),\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n        };\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n}\nexports.Chess = Chess;\n//   return {\n//     /***************************************************************************\n//      * PUBLIC CONSTANTS (is there a better way to do this?)\n//      **************************************************************************/\n//     SQUARES: (function () {\n//       /* from the ECMA-262 spec (section 12.6.4):\n//        * \"The mechanics of enumerating the properties ... is\n//        * implementation dependent\"\n//        * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n//        * ordered correctly\n//        */\n//       var keys = []\n//       for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n//         if (i & 0x88) {\n//           i += 7\n//           continue\n//         }\n//         keys.push(algebraic(i))\n//       }\n//       return keys\n//     })(),\n//     FLAGS: FLAGS,\n// }\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAAA;AACbA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAGF,OAAO,CAACG,WAAW,GAAGH,OAAO,CAACI,OAAO,GAAGJ,OAAO,CAACK,gBAAgB,GAAGL,OAAO,CAACM,IAAI,GAAGN,OAAO,CAACO,KAAK,GAAGP,OAAO,CAACQ,IAAI,GAAGR,OAAO,CAACS,MAAM,GAAGT,OAAO,CAACU,MAAM,GAAGV,OAAO,CAACW,IAAI,GAAGX,OAAO,CAACY,KAAK,GAAGZ,OAAO,CAACa,KAAK,GAAG,KAAK,CAAC;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,OAAO,CAACa,KAAK,GAAG,GAAG;AACnBb,OAAO,CAACY,KAAK,GAAG,GAAG;AACnBZ,OAAO,CAACW,IAAI,GAAG,GAAG;AAClBX,OAAO,CAACU,MAAM,GAAG,GAAG;AACpBV,OAAO,CAACS,MAAM,GAAG,GAAG;AACpBT,OAAO,CAACQ,IAAI,GAAG,GAAG;AAClBR,OAAO,CAACO,KAAK,GAAG,GAAG;AACnBP,OAAO,CAACM,IAAI,GAAG,GAAG;AAClBN,OAAO,CAACK,gBAAgB,GAAG,0DAA0D;AACrF,IAAMS,KAAK,GAAG,CAAC,CAAC;AAChB,IAAMC,KAAK,GAAG;EACVC,MAAM,EAAE,GAAG;EACXC,OAAO,EAAE,GAAG;EACZC,QAAQ,EAAE,GAAG;EACbC,UAAU,EAAE,GAAG;EACfC,SAAS,EAAE,GAAG;EACdC,YAAY,EAAE,GAAG;EACjBC,YAAY,EAAE;AAClB,CAAC;AACD;AACAtB,OAAO,CAACI,OAAO,GAAG,CACd,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CACjD;AACD,IAAMmB,IAAI,GAAG;EACTP,MAAM,EAAE,CAAC;EACTC,OAAO,EAAE,CAAC;EACVC,QAAQ,EAAE,CAAC;EACXC,UAAU,EAAE,CAAC;EACbC,SAAS,EAAE,EAAE;EACbC,YAAY,EAAE,EAAE;EAChBC,YAAY,EAAE;AAClB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAME,IAAI,GAAG;EACTC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EAAEC,EAAE,EAAE,CAAC;EACtDC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAC9DC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAC9DC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAC9DC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAC9DC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAC9DC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,EAAE;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAClEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE,GAAG;EAAEC,EAAE,EAAE;AACvE,CAAC;AACD,IAAMC,YAAY,GAAG;EACjBC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EACnBC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE;AAC1B,CAAC;AACD,IAAMC,aAAa,GAAG;EAClBC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EACvCH,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EACrBI,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;EACnBC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;EACrCC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACxC,CAAC;AACD;AACA,IAAMC,OAAO,GAAG,CACZ,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EACjD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CACjD;AACD;AACA,IAAMC,IAAI,GAAG,CACT,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EACjD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EACrD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE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"},"metadata":{},"sourceType":"script","externalDependencies":[]}